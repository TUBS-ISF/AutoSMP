package de.tubs.cs.isf.AutoSMP.util;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.nio.file.StandardOpenOption;
import java.util.ArrayList;
import java.util.List;
import java.util.Objects;

/**
 * This class is responsible to write results of the sampling framework properly
 * to CSV files. Generally one {@link CSVWriter} is created for each output file
 * and supports the process to write information into these files.
 * 
 * @author Joshua Sprey
 * @author Sebastian Krieter
 *
 */
public class CSVWriter {
	/** Token to start a new line in the CSV file. */
	private static final String NEWLINE = System.lineSeparator();

	/** Indicates whether a writer should recreate or append to the file. */
	private boolean append = false;
	/** Contains all headers for the csv file. */
	private List<String> header = null;
	private boolean keepLines = false;

	/** Indicates that a new file should be created. */
	private boolean newFile = true;
	private int nextLine = 0;

	/**
	 * The path to a folder that should contain the csv files generated by this
	 * {@link CSVWriter}.
	 */
	private Path outputPath = Paths.get("");

	/** Path for the actual csv file. */
	private Path path;
	/** The separator for the csv file. Default: ';' */
	private String separator = ";";
	private final List<List<String>> values = new ArrayList<>();

	/**
	 * Adds a given string as a header to the csv file.
	 * 
	 * @param headerValue The new header to add to the csv file.
	 */
	public void addHeaderValue(String headerValue) {
		header.add(headerValue);
	}

	/**
	 * Adds a data row as string list to the csv writer. Does not write the
	 * information to the file. For that use the {@link CSVWriter#flush()} method.
	 * 
	 * @param line The new header to add to the csv file.
	 */
	public void addLine(List<String> line) {
		values.add(line);
	}

	/**
	 * Adds a new entry to the current row of the csv writer. Does not write the
	 * information to the file. For that use the {@link CSVWriter#flush()} method.
	 * 
	 * @param o Value to add.
	 */
	public void addValue(Object o) {
		values.get(values.size() - 1).add(o.toString());
	}

	/**
	 * Creates a new empty data set to the csv writer. Does not write the
	 * information to the file. For that use the {@link CSVWriter#flush()} method.
	 * 
	 * The empty line can be directly filled with informations by calling
	 * {@link CSVWriter#addValue(Object)}.
	 * 
	 * @see CSVWriter#addValue(Object)
	 */
	public void createNewLine() {
		values.add(new ArrayList<>());
	}

	@Override
	public boolean equals(Object obj) {
		if (this == obj) {
			return true;
		}
		if (obj == null || getClass() != obj.getClass()) {
			return false;
		}
		return Objects.equals(path, ((CSVWriter) obj).path);
	}

	/**
	 * Flushes the information of the csv writer to the file. All values are removed
	 * from the writer when {@link CSVWriter#setKeepLines(boolean)} hasn't been set
	 * to {@link Boolean#TRUE}.
	 */
	public void flush() {
		if (path != null) {
			final StringBuilder sb = new StringBuilder();
			for (int i = nextLine; i < values.size(); i++) {
				writer(sb, values.get(i));
			}
			try {
				Files.write(path, sb.toString().getBytes(), StandardOpenOption.APPEND);
				if (keepLines) {
					nextLine = values.size();
				} else {
					values.subList(1, values.size()).clear();
					nextLine = 1;
				}
			} catch (IOException e) {
				e.printStackTrace();
			}
		}
	}

	/**
	 * @return The list containing all headers of the csv file.
	 */
	public List<String> getHeader() {
		return header;
	}

	/**
	 * @return The path to a folder that should contain the csv files generated by
	 *         this {@link CSVWriter}.
	 */
	public Path getOutputPath() {
		return outputPath;
	}

	/**
	 * @return The separator for the csv file.
	 */
	public String getSeparator() {
		return separator;
	}

	/**
	 * @return The list containing all data rows, except header, of the csv file.
	 */
	public List<List<String>> getValues() {
		return values;
	}

	@Override
	public int hashCode() {
		return path.hashCode();
	}

	/**
	 * @return Whether to append or to create a new file.
	 */
	public boolean isAppend() {
		return append;
	}

	/**
	 * @return Whether to keep values after flushing the writer.
	 */
	public boolean isKeepLines() {
		return keepLines;
	}

	/**
	 * Resets the csv writer by removing all cached values. Does not
	 */
	public void reset() {
		if (!values.isEmpty()) {
			values.subList(1, values.size()).clear();
		}
		nextLine = 0;
	}

	/**
	 * Removes the last row from the csv writer.
	 */
	public void resetLine() {
		if (!values.isEmpty()) {
			values.remove(values.size() - 1);
		}
	}

	/**
	 * Saves the information of the csv writer to a given file.
	 * 
	 * @param p Path of the file.
	 * @return {@link Boolean#TRUE} if everything went accordingly, otherwise
	 *         {@link Boolean#FALSE}
	 */
	public boolean saveToFile(Path p) {
		try {
			Files.write(p, toString().getBytes(), StandardOpenOption.APPEND, StandardOpenOption.CREATE);
			return true;
		} catch (IOException e) {
			e.printStackTrace();
		}
		return false;
	}

	/**
	 * @return The list containing all headers of the csv file.
	 */
	public void setAppend(boolean append) {
		this.append = append;
	}

	/**
	 * Sets the file name depending on the given path.
	 * 
	 * @param fileName File name for the csv file.
	 */
	public void setFileName(Path fileName) {
		setPath(outputPath.resolve(fileName));
	}

	/**
	 * Sets the file name depending on the given string.
	 * 
	 * @param fileName File name for the csv file.
	 */
	public void setFileName(String fileName) {
		setPath(outputPath.resolve(fileName));
	}

	/**
	 * Sets the headers for the csv file.
	 * 
	 * @param headerList A list containing all the headers for the csv file.
	 */
	public void setHeader(List<String> headerList) {
		this.header = new ArrayList<>(headerList);
		if (values.isEmpty()) {
			values.add(this.header);
		} else {
			values.set(0, this.header);
		}
		if (!newFile) {
			nextLine = 1;
		}
	}

	/**
	 * Determines whether values should persist after performing a
	 * {@link CSVWriter#flush()} operation.
	 * 
	 * @param {@link Boolean#TRUE} makes value persist after flushing.
	 */
	public void setKeepLines(boolean keepLines) {
		this.keepLines = keepLines;
	}

	/**
	 * Sets the path to a folder that should contain the csv files generated by this
	 * {@link CSVWriter}.
	 *
	 * @param outputPath Desired path.
	 * @return {@link Boolean#TRUE} if everything went correctly, otherwise
	 *         {@link Boolean#FALSE}
	 */
	public boolean setOutputPath(Path outputPath) {
		if (Files.isDirectory(outputPath)) {
			this.outputPath = outputPath;
			return true;
		} else if (!Files.exists(outputPath)) {
			try {
				Files.createDirectories(outputPath);
			} catch (IOException e) {
				e.printStackTrace();
				return false;
			}
			this.outputPath = outputPath;
			return true;
		} else {
			return false;
		}
	}

	/**
	 * Sets the path for the csv file.
	 * 
	 * @param path Desired path for the csv file.
	 */
	private void setPath(Path path) {
		this.path = path;
		try {
			if (append) {
				newFile = !Files.exists(path);
			} else {
				Files.deleteIfExists(path);
				newFile = true;
			}
			if (newFile) {
				Files.createFile(path);
			}
		} catch (IOException e) {
			e.printStackTrace();
		}
		reset();
	}

	/**
	 * Sets the separator for the csv file.
	 * 
	 * @param separator The desired separator.
	 */
	public void setSeparator(String separator) {
		this.separator = separator;
	}

	@Override
	public String toString() {
		StringBuilder sb = new StringBuilder();
		for (List<String> line : values) {
			writer(sb, line);
		}
		return sb.toString();
	}

	private void writer(StringBuilder sb, List<String> line) {
		for (String value : line) {
			if (value != null) {
				sb.append(value);
			}
			sb.append(separator);
		}
		if (line.isEmpty()) {
			sb.append(NEWLINE);
		} else {
			final int length = sb.length() - 1;
			sb.replace(length, length + separator.length(), NEWLINE);
		}
	}

}
